# 运算符

`typescript` 提供了强大的类型运算能力，可以使用各种类型运算符，对已有的类型进行计算，得到新类型。

## `keyof` 运算符

`keyof` 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型：

```typescript
type MyObj = {
  foo: number;
  bar: string;
};

type Keys = keyof MyObj; // 'foo'|'bar'
```

由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是：`string` | `number` | `symbol`：

```typescript
type KeyT = keyof any; // string | number | symbol
```

而**对于没有自定义键名的类型使用 `keyof` 运算符，就会返回 `never` 类型**，表示不存在这样类型的键名：

```typescript
type KeyT = keyof object; // never
```

以上示例中，由于 `object` 类型没有自身的属性，也就是没有键名，所以 `keyof object` 返回 `never` 类型。

由于 `keyof` 返回的类型是 `string` | `number` | `symbol`，**如果某些场景中只需要其中的一种类型，要么也可以使用交叉类型的写法**：

```typescript
type Capital<T extends string> = Capitalize<T>

type MyKeys<Obj extends object> = Capital<keyof Obj>
```

以上示例中，类型 `Capital` 只接受字符串作为类型参数，传入 `keyof Obj` 会报错，原因是这时的类型参数是 `string|number|symbol`，跟字符串不兼容，而如果使用的是交叉类型写法，就不会报错：

```typescript
type MyKeys<Obj extends object> = Capital<string & keyof Obj>;
```

上面示例中，`string & keyof Obj` 等同于 `string & string|number|symbol` 进行交集运算，最后返回 `string`，因此 `Capital<T extends string>` 就不会报错了。

而如果对象属性名采用了索引形式，那么 `keyof` 也会返回属性名的索性类型：

```typescript
{
    interface T {
    	[prop: number]: number
	}

	// number
	type keyT = keyof T
}

{
    interface T {
    	[prop: string]: number
	}
    
    // string | number
    type keyT = keyof T
}

```

以上示例中，第二个示例返回的类型是 `string` | `number`，原因是 `JavaScript` 中属性名为字符串时，包含了属性名为数值的情况，这是数值属性名会自动转换成字符串。

### `keyof` 运算符的用途

**`keyof` 运算符通常用于精准表达对象的属性类型**。 

例如，想要取出对象中某个指定属性的值，在 `ts` 中的写法是：

```typescript
// 类型声明不够明确，参数 obj 与 key 之间的关系没有表示，返回值类型不确定
function prop (obj: object, key: string): unknown {
    return obj[key]
}

// K extends keyof Obj表示K是Obj的一个属性名，返回值类型 Obj[k] 就表示 k 这个属性值的类型
function prop<Obj, k extends keyof Obj>(obj: Obj, key: k): Obj[k] {
  return obj[key]
}
```

而另一个用途就是用于属性映射，即将一个类型的所有属性逐一映射成其他值。

```typescript
type NewProps<Obj> = {
  [Prop in keyof Obj]: boolean;
};

// 用法
type MyObj = { foo: number };

// 等于 { foo: boolean; }
type NewObj = NewProps<MyObj>;
```

上面示例中，类型`NewProps`是类型`Obj`的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了`boolean`。

```typescript
type Concrete<Obj> = {
  [Prop in keyof Obj]-?: Obj[Prop];
};

// 用法
type MyObj = {
  foo?: number;
};

// 等于 { foo: number; }
type NewObj = Concrete<MyObj>;
```

上面示例中，`[Prop in keyof Obj]`后面的`-?`表示去除可选属性设置。对应地，还有`+?`的写法，表示添加可选属性设置。



## `in` 运算符

在 `js` 中，`in` 运算符通常用来确定对象是否包含某个属性名；`in` 运算符的左侧是一个字符串，表示属性名，右侧是一个对象；它将会返回一个布尔值。

而在 `ts` 的类型运算中，**`in` 运算符主要是用来取出（遍历）联合类型的每一个成员类型**。

```typescript
type U = "a" | "b" | "c"

type Foo = {
    [prop in U]: number
}

// 等同于
type Foo = {
  a: number;
  b: number;
  c: number;
};
```

上面示例中，`[Prop in U]` 表示依次取出联合类型 `U` 的每一个成员。 



## `[]` 方括号运算符

**方括号运算符 `[]` 用于取出对象的键值类型**，比如 `T[K]` 会返回对象 `T` 的属性 `K` 的类型。