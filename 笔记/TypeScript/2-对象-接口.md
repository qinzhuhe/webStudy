# 对象类型-接口

在面向对象语言中，**接口（`Interfaces`）**是一个很重要的概念，它是对行为的抽象，而具体如何行动则需要**类（`Classes`）**去**实现（`Implement`）**。

而在 `typescript` 中，它使用**接口来定义对象的类型**，除了可用于对类的一部分行为进行抽象以外，也常用于对【对象的形状（`Shape`）】进行描述。



## 类型定义

```typescript
interface Person {
    name: string,
    age: number
}

let tom: Person = {
    name: 'tom',
    age: 25
}
```

在以上代码中，首先定义了一个接口 `Person`，接着定义了一个变量 `tom`，将它的类型指向 `Person`，这样一来，就约束了 `tom` 的结构形态必须和接口 `Person` 一致。

一旦约束构成，那么定义的变量就不能比接口少一些或多一些属性，**赋值的时候，变量的形状必须和接口的形状保持一致**，否则将会发生报错：

```typescript
{ // 缺少属性
    interface Person {
        name: string,
        age: number
    }

    let tom: Person = {
        name: 'tom',
    }

    // Property 'age' is missing in type '{ name: string; }' but required in type 'Person'
}

{ // 多余属性
    interface Person {
        name: string,
        age: number
    }

    let tom: Person = {
        name: 'tom',
        age: 25,
        gender: 'male'
    }

    // Property 'age' is missing in type '{ name: string; }' but required in type 'Person'
}

```

<!--接口一般首字母大写。有的编程语言中会建议接口的名称前缀加上 `I` 前缀-->

## 可选属性

如果在使用的时候希望不要对形状进行完全匹配，那么可以用**可选属性**进行声明。

```typescript
interface Person {
  name: string,
  age?: string
}

let tom: Person = {
  name: 'tom'
}
```

可选属性的含义就是该属性可以不存在 `undefined`，但注意，这时候仍然不允许添加未定义的属性。

## 任意属性

如果在使用的时候希望一个接口允许有类似任意值一样的属性，那么同样的，可以使用**任意属性**进行声明。

```typescript
interface Person {
  name: string,
  age?: string,
  [propName: string]: any
}

let tom: Person = {
  name: 'tom',
  gender: 'male'
}
```

使用 **`[propName: string]: any`**定义了任意属性取`string`类型的值。

但需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它类型的子集**：

```typescript
interface Person {
  name: string,
  age?: string,
  [propName: string]: string
}

let tom: Person = {
  name: 'tom',
  age: 10,
  gender: 'male'
}

//  Property 'age' of type 'number' is not assignable to 'string' index type 'string'
```

如果在接口中既不想使用 `any` 破坏拘束性，又不确定属性的当前类型，同样也可以**使用联合类型进行**组合：

```typescript
interface Person {
  name: string,
  age?: string,
  [propName: string]: string | number
}

let tom: Person = {
  name: 'tom',
  age: 10,
  gender: 'male'
}
```

<!--要注意的是，在接口中定义任意属性的值时，如果属性中定义了一个可选类型，那么在属性值不是 any 的情况下，则应该在前面指定一个 undefined 进行判断，这是因为本身可选属性就是一个定义的类型加上 undefined 组合而成的，但如果不在任意属性中加上 undefined 也可以编译成功，但会有错误提醒 -->

```typescript
// 完整用法
interface Person {
    ...,
    age?: number,
    [propName: string]: undefined | number
}
```

## 只读属性

如果在定义接口时希望后续对象的一些字段只能在创建的时候被赋值，那么可以**使用 `readonly` 定义只读属性**：

```typescript
interface Person {
  readonly id: bigint,
  name: string,
  age?: string,
  [propName: string]: string | number
}

let tom: Person = {
  id: 0,
  name: 'tom',
  age: 10,
  gender: 'male'
}

tom.id = 1 // Cannot assign to 'id' because it is a read-only property.
```

