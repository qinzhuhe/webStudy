# 工具类型原理

为了方便开发者进行使用， `typescript` 内置了一些常用的工具类型，比如 `Partial`、`Required`、`Readonly`、`Record` 和 `ReturnType` 等。

而在对这些工具类型进行使用前，有必要先对几个概念进行理解，从而方便开发时更好的进行使用。

## 映射类型（`Mapped Types`）

映射类型的概念是类型编程的重要底层组成，通常用于在就有类型的基础上进行改造，包括接口包含字段、字段的类型、修饰符（`readonly` 与 `?`）等等。

假设存在一个接口 A，然后再声明一个 B 接口，它的字段与接口 A 完全相同，但是其中的类型不同，该如何进行声明？

```typescript
interface A {
    name: string
    title: string
    age: number
}

// 任何声明 B？
```

按照以上例子，当然，可以使用重新声明手写的方法可以进行实现，但会让代码变得笨重且冗余。

而这时，如果将接口换成对象，是否就可以直接 `new` 一个新对象，然后通过遍历 `A` 的键名（`object.keys()`）来填充这个对象：

```typescript
interface A {
    name: string
    title: string
    age: number
}

type ITypesObj<T> = {
    [K in keyof T]: string
}

type B = ITypesObj<A>

/**
 * type B = {
 *   name: string;
 *   title: string;
 *   age: string;
 * }
 */
```

而此处的 `in` ，可以将它理解成 `for...in`，也就是说可以通过 `in` 遍历到联合类型里面的每个类型。

## 条件类型 （`Conditional Types`）

条件类型（`Conditional Types`）的语法实际上就是[三元表达式]，只不过与 `javascript` 中不同的是，相比于**值类型**中的三元表达式最终会被计算出一个**值**，在 `typescript` 中，它最终会被计算出一个类型。

条件类型使用 `extends` 关键字进行操作：

```typescript
AType extends BType ?  CType :  DType
```



```typescript
// 可以简单理解为 U 中的属性是否存储在 T 中，也就说，如果 T 能够赋值给 U，那么类型就是 x，否则为 y
T extends U ? x : y
```

这里用条件类型一个比较常用的场景：**泛型约束**来对上面的例子进行推导：

```typescript
function pickValue<T extends object, U extends keyof T>(
	obj: T,
     keys: U[]
): T[U][] {
     return keys.map(key => obj[key])
}
```

以上例子中的 `T extends object` 以及 `U extends keyof T` 都是泛型约束，分别**将 `T` 约束为对象类型（object）以及将 `U` 约束为 `T` 的属性名的字面量联合类型**。

泛型约束通常被用来收束泛型，也就是说，这种场景下的 `extends` 就是为了让类型收窄。

同时，就像三元表达式能够进行嵌套之外，条件类型同样能够进行嵌套，例如在一些框架源码中存在的许多嵌套的条件类型，而目的就是为了通过**条件类型将类型约束收拢到非常精确的范围内**。

```typescript
type TypeName<T> = T extends string
  ? "string"
  : T extends number
  ? "number"
  : T extends boolean
  ? "boolean"
  : T extends undefined
  ? "undefined"
  : T extends Function
  ? "function"
  : "object";
```

---

## 分布式条件类型（`Distributive Conditional Types`）

分布式条件类型的定义是：**对于属于裸类型参数的检查类型，条件类型会在实例化时期自动的分发到联合类型上**。

分布式条件类型虽然是依据在条件类型的基础上，但是它属于一个比较抽象且难以理解的概念，先书写一个例子：

```typescript
// 声明一个条件类型
type TypeName<T> = T extends string
  ? 'string'
  : T extends number
  ? 'number'
  : T extends boolean
  ? 'boolean'
  : T extends undefined
  ? 'undefined'
  : T extends Function
  ? 'function'
  : 'object'

// 使用上面的 TypeName 类型别名
// "string" | "function"
type T1 = TypeName<string | (() => void)>

// "string" | "object"
type T2 = TypeName<string | number[]>

```

以上例子的运行中，可以发现条件类型的推导结果都是一个联合类型，并且结果就是**类型参数被依次进行条件判断的结果**。

再来两个例子：

```typescript
type Naked<T> = T extends boolean ? 'Y' : 'N'

/**
* 先分发到 Naked<number> | Naked<boolean>
* 然后到 "N" | "Y"
*/
type neaked = Naked<boolean | number>;

```

```typescript
type Wrapped<T> = [T] extends [boolean] ? 'Y' : 'N'

/**
* 不会分发，直接就会判断 [number | boolean] extends [boolean]
* 然后到 "N"
*/
type wrapped = Wrapped<boolean | number>;
```

### 概念

结合以上三个例子，就可以理解几个概念了：

- 裸类型参数：没有额外被接口 / 类型别名包裹过的的参数，就像是被 `[]` 包裹后就不能再被称为裸类型参数
- 实例化：条件类型的判断过程
- 分发至联合类型的过程：
  - 对于 `TypeName` 来说，它内部的类型参数 `T` 是没有被包裹过的，所以 `TypeName<string | (() => void)>` 会被分发为 `TypeName<string> | TypeName<(() => void)>`，然后再次进行判断，最后分发为 `"string" | "function"`
  - 抽象下具体过程：`TypeName(A | B | C) extends T ? X : Y` 相当于 `(A extends T ? X : Y) | (B extends T ? X : Y) | (C extends T ? X : Y)`

用一句话概括：**没有被额外包装的联合类型参数，在条件类型进行判定时会将联合类型分发，分别进行判断**。

而在例子`3`中，联合类型 `boolean | number` 被包装成了 `[boolean | number]`，所以它不会分别进行判断分发。

