<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>第一块</title>
</head>
<body>
	<script>
		// apply和call的使用
		// 作用：可以改变this的指向

		// "use strict";
		// function f1(x,y){
		// 	console.log("结果是:"+(x+y)+this);
		// 	return "10000";
		// }
		// f1(10,20);//函数的调用

		// console.log("=====");
		// 此时的f1实际上是当成对象来使用的
		// apply和call方法也是函数的调用的方式
		// f1.apply();
		// f1.call();

		// console.log("======");
		// f1.apply(null);
		// f1.call(null);

		// apply和call方法中如果没有传入参数，或者传入的是null，那么调用该方法的函数对象中的this就是默认的window

		// f1.apply(null,[100,200]);
		// f1.call(null,100,200);

		// apply和call都可以让函数或者方法来调用，传入参数和函数自己调用的写法不一样，但是效果是一样的。

		// var res1 = f1.apply(null,[100,20]);
		// var res2 = f1.call(null,10,20);
		// console.log(res1);
		// console.log(res2);

		console.log("========");
		// function f1(x,y){
		// 	console.log("这个函数是window对象的一个方法："+(x+y)+this.age);
		// }
		// window.f1(10,20);
		// // obj是一个对象
		// var obj = {
		// 	age : 10,
		// 	sex : "男"
		// };

		// window.f1.apply(obj,[10,20]);
		// window.f1.call(obj,10,20);
		// console.dir(obj);

		// apply和obj的作用是一样的，它们都可以用来改变this的指向

		function Person(age,sex){
			this.age = age;
			this.sex = sex;
		}
		// 通过原型添加方法
		Person.prototype.sayHi = function (x,y){
			console.log("下午见"+this.sex);
			return 10000;
		};

		var per = new Person(10,"男");
		per.sayHi();

		console.log("========");
		function Student(name,sex){
			this.name = name;
			this.sex = sex;
		}
		var stu = new Student("小明","女");
		var r1 = per.sayHi.apply(stu,[10, 20]);
		var r2 = per.sayHi.call(stu,10,20);

		console.log(r1);
		console.log(r2);
	</script>
</body>
</html>